# 05-浏览器：一个浏览器是如何工作的？（阶段五）

在前几篇整理中，经历了很多过程，这一篇主要讲重绘的过程，总计一下浏览器的整体流程就是下面的这一部分

> URL->字符流->词（token）->构建DOM树->结合CSS形成CSSOM->计算元素位置和大小（回流）->绘制

浏览器位图操作部分分成三个部分，分别是渲染，合成，绘制这三个部分

## 渲染

这里特指把模型变成位图的过程。位图就是在内存里建立一张二维表格，将每一张图片的每个像素对应的颜色保存进去（位图信息在DOM树中占据浏览器内存最多的信息，在做内存占用优化的时候，主要考虑的也是这一部分）。

渲染的过程就是将每一个元素对应的盒变成位图，一个盒对应一个位图，每个盒的特性如何绘制，都有对应的标准规定。

渲染过程整体分为两大类：图形和文字，两者都需要底层库的支持。

最普遍的情况下，渲染生成的位图尺寸和上一步排版时占据的尺寸相同，但实际情况是，很多属性会影响渲染位图的大小，比如阴影，因此为了优化，浏览器会把阴影当作一个独立的盒来处理。

这里的渲染是不会把子元素渲染到位图上的，当父子元素相对位置发生变化时，保证渲染结果能最大程度的被缓存，减少重新渲染。

## 合成

是基于性能的考量，并非实现浏览器的必要一环。合成的过程，就是为一些元素创建一个合成后的位图，称为合成层。

合成策略就是猜测可能变化的元素，把它排除到合成之外。一般根据position、transform等属性来决定合成策略。

在新的CSS标准中，规定了will-change属性，可以由业务代码提示浏览器的合成策略。

## 绘制

绘制始值把位图最终绘制到屏幕上，变成肉眼可见的图像的过程，一般来说浏览器不需要代码来处理这个过程，而是将最重要显示的为徒交给操作系统即可。因此，把位图合成到最终位图的操作称为绘制。

把已经得到的每个元素的位图以及部分合成后的结果，按照z-index依次绘制到屏幕上。但是会带来性能上的问题，前端在CSS上的优化应该尽量避免“重排”和“重绘”。

绘制发生的频率很高，一种方案就是“脏矩形”，把屏幕均匀的分成若干矩形区域，只将影响的几个区域重新绘制即可，只要设置合适的矩形区域大小，就能很好的控制绘制时的消耗。（学计算机图形学的时候还有点印象）




