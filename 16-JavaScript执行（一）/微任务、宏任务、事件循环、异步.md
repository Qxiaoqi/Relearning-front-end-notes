# 16-JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？

这一部分主要讲述了JavaScript的执行，涉及到的知识点
* 事件循环
* 微任务宏任务
* 异步执行
* async和generator对比

## 事件循环(Event Loop)

[事件循环-阮一峰](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)

浏览器的事件循环和NodeJs的事件循环不同。这里只整理浏览器的事件循环，对Node的运行并不是很熟悉，因此不做整理。

JavaScript是单线程的，因此同一个时间只能做一件事。JavaScript作为浏览器语言，如果采用多线程可能会带来一些复杂的同步问题，JavaScript主要用途是和用户互动，操作DOM。

单线程意味着需要排队，如果前一个任务时间很长，后面的任务就会被阻塞。IO（比如Ajax）很慢，如果一直等待会造成CPU空闲（操作系统中的多道批处理操作系统）。浏览器和服务端不同。浏览器端受限于网络原因，网络不好的情况下，请求可能会很长时间才会响应。因此对于浏览器端来讲，更合理的方案是异步（CommonJs和AMD&CMD方案原因同）。

对任务来讲，可以分为同步任务和异步任务。同步任务进入主线程，按顺序执行。异步任务不进入主线程，进入"任务队列"，只有异步任务有运行结果了，就会在"任务队列"中放置事件。主线程上的同步任务执行完毕后，才会读取"任务队列"，异步任务才会进入执行栈，开始执行（执行异步任务的回调函数）。

说到事件循环，就要提到定时器的问题（setTimeout和setInterval）。定时器进入"执行队列"，因此会等待执行栈内的任务执行完毕后才会执行，如下代码。执行顺序是1 2。

```js
setTimeout(function(){console.log(2);}, 0);
console.log(1);
```

这样就会产生一个问题，函数设置的执行时间未必一定会执行，设置的时间只是到目标时间时将其放入"任务队列"，如果执行找还有任务，那么就不会执行。如下，5s后才会执行，并不是1s。

```js
setTimeout(function(){console.log("执行");}, 1000);
(function func() {
  var begin = Date.now();
  while(Date.now() - begin < 5000) {
    // console.log(1);
  }
})();
```

## 微任务宏任务




整理事件循环，微任务宏任务，异步等等

里面有几个问题，为什么作者对async和generator的见解和阮一峰不同？有待考证